"""ACIDh message handler wrapper.

At this point of the refactor all ACIDh logic still lives in `core.node`.
This class merely forwards incoming messages to those original methods so we
can decouple the router and progressively move the real state machine here in
future commits.
"""

from __future__ import annotations

from typing import Callable, Dict, List

from protocol.common.message import MessageType, MVBAMessage

# New independent state machine
from .state import ACIDState, Outbound


class ACIDHandler:
    """Thin proxy that delegates to the legacy methods on *node*."""

    _ACID_TYPES: List[MessageType] = [
        MessageType.SHARE,
        MessageType.VOTE,
        MessageType.LOCK,
        MessageType.READY,
        MessageType.FINISH,
    ]

    def __init__(self, node):
        self.node = node
        self._state: ACIDState | None = None

    # ------------------------------------------------------------------
    # Public API used by MessageRouter
    # ------------------------------------------------------------------

    def handle(self, msg: MVBAMessage) -> None:  # pragma: no cover
        """Entry-point used by MessageRouter.

        It lazily instantiates :class:`ACIDState` once the *Node* has finished
        bootstrap and all required parameters are available.
        """

        # Preserve pre-synchronisation buffering behaviour
        if not self.node.sync_complete:
            self.node._route_acid_message(msg)
            return

        # Lazily create state after bootstrap
        if self._state is None:
            self._state = ACIDState(
                node_id=self.node.node_id,
                total_nodes=self.node.total_nodes,
                byzantine_threshold=self.node.byzantine_threshold,
                session_id=self.node.session_id,
                logger=self.node.logger,
            )

        # Normalise Enum class (legacy nodes still use their own MessageType)
        if not isinstance(msg.msg_type, MessageType):
            msg.msg_type = MessageType(msg.msg_type.value)

        # For FINISH we must also update Node's election counters
        if msg.msg_type == MessageType.FINISH:
            self.node._handle_finish_message(msg)

        # Feed message into the state machine (may generate outbound msgs)
        outbound: List[Outbound] = self._state.handle_message(msg)

        # ------------------------------------------------------------------
        # Mirror selected flags onto the legacy Node for ABBBA/ABBA inputs.
        # These two structures are consulted when spawning ABBBA instances,
        # therefore they must stay consistent with the canonical ACIDState.
        # ------------------------------------------------------------------
        self.node.acidh_ready = dict(self._state.acidh_ready)
        self.node.acidh_finish = dict(self._state.acidh_finish)

        # Deliver any messages generated by the state machine
        for act in outbound:
            # Local processing of self-generated FINISH (mimics legacy path)
            if act.msg.msg_type == MessageType.FINISH:
                self.node._handle_finish_message(act.msg)

            if act.target is None:
                self.node.zmq_manager.broadcast_message(act.msg)
            else:
                self.node.zmq_manager.send_message(act.target, act.msg)
