"""DRh message handler wrapper.

This class wraps the pure DRhState machine and handles coordination with
the Node class for inter-protocol communication (ABBA â†’ DRh triggering) and
message delivery via ZeroMQ.
"""

from __future__ import annotations

from typing import List

from protocol.common.message import MessageType, MVBAMessage

# New independent state machine
from .state import DRhResult, DRhState, Outbound


class DRhHandler:
    """Message handler that delegates DRh protocol logic to DRhState."""

    _DRH_TYPES: List[MessageType] = [
        MessageType.ECHOSHARE,
    ]

    def __init__(self, node):
        self.node = node
        self._state: DRhState | None = None

    # ------------------------------------------------------------------
    # Public API used by MessageRouter and Node coordination
    # ------------------------------------------------------------------

    def handle(self, msg: MVBAMessage) -> None:  # pragma: no cover
        """Entry-point used by MessageRouter for ECHOSHARE messages.

        It lazily instantiates :class:`DRhState` once the *Node* has finished
        bootstrap and all required parameters are available.
        """

        # Preserve pre-synchronisation buffering behaviour
        if not self.node.sync_complete:
            self.node._route_drh_message(msg)
            return

        # Lazily create state after bootstrap
        if self._state is None:
            self._state = DRhState(
                node_id=self.node.node_id,
                total_nodes=self.node.total_nodes,
                byzantine_threshold=self.node.byzantine_threshold,
                session_id=self.node.session_id,
                logger=self.node.logger,
            )

        # Normalise Enum class (ensure consistent MessageType usage)
        if not isinstance(msg.msg_type, MessageType):
            msg.msg_type = MessageType(msg.msg_type.value)

        # Feed message into the state machine (may generate outbound msgs)
        outbound: List[Outbound] = self._state.handle_message(msg)

        # Deliver any messages generated by the state machine
        self._deliver_outbound_messages(outbound)

        # After processing ECHOSHARE, attempt output for this leader/commitment
        if msg.msg_type == MessageType.ECHOSHARE:
            leader_id = msg.data["leader"]
            commitment = msg.data["commitment"]
            self._attempt_output_coordination(leader_id, commitment)

    def start_instance(self, leader_id: int) -> None:
        """Start DRh instance for the given leader (called by ABBA when it decides 1).

        This is the main entry point for inter-protocol coordination.
        """
        if self.node.mvba_decided:
            return  # Already decided, nothing to do

        # Ensure state machine is initialized
        if self._state is None:
            self._state = DRhState(
                node_id=self.node.node_id,
                total_nodes=self.node.total_nodes,
                byzantine_threshold=self.node.byzantine_threshold,
                session_id=self.node.session_id,
                logger=self.node.logger,
            )

        # Get ACIDh state for coordination
        acid_locks, acid_shares = self._get_acid_state()

        # Start the DRh instance
        outbound: List[Outbound] = self._state.start_instance(
            leader_id, acid_locks, acid_shares
        )

        # Deliver any messages generated (typically ECHOSHARE)
        self._deliver_outbound_messages(outbound)

        # If we already have enough shares, attempt output immediately
        if leader_id in acid_locks and acid_locks[leader_id] == 1:
            commitment = acid_shares.get(leader_id, (-1, -1, -1))[0]
            if commitment != -1:
                self._attempt_output_coordination(leader_id, commitment)

    def reset_round_state(self) -> None:
        """Reset DRh state for a new round."""
        if self._state is not None:
            self._state.reset_round_state()

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _get_acid_state(self) -> tuple[dict, dict]:
        """Get ACIDh state for coordination."""
        if hasattr(self.node, "acid_handler") and getattr(
            self.node.acid_handler, "_state", None
        ):
            acid_state = self.node.acid_handler._state
            return dict(acid_state.acidh_locks), dict(acid_state.acidh_shares)
        else:
            # Fallback to mirrored state (should rarely be used)
            return dict(getattr(self.node, "acidh_locks", {})), {}

    def _attempt_output_coordination(self, leader_id: int, commitment: str) -> None:
        """Attempt DRh output and handle MVBA termination if successful."""
        if self.node.mvba_decided or self._state is None:
            return

        # Import predicate function (avoiding circular imports)
        from node import predicate

        # Attempt to decode and validate
        outbound, result = self._state.attempt_output(
            leader_id, commitment, predicate, self.node
        )

        # Deliver any messages generated
        self._deliver_outbound_messages(outbound)

        # Handle successful decode â†’ MVBA termination
        if result is not None:
            self.node.mvba_decided = True
            self.node.logger.info(
                "ðŸŽ‰ MVBA DECIDED via DRh[%s]: %s",
                result.leader_id,
                result.decoded_value,
            )

    def _deliver_outbound_messages(self, outbound: List[Outbound]) -> None:
        """Deliver outbound messages via ZeroMQ."""
        for act in outbound:
            # Handle local delivery for self-generated messages
            if act.msg.sender_id == self.node.node_id:
                self.handle(act.msg)  # Local delivery

            # Send via ZeroMQ
            if act.target is None:
                self.node.zmq_manager.broadcast_message(act.msg)
            else:
                self.node.zmq_manager.send_message(act.target, act.msg)
